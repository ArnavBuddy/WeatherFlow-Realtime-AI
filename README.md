# Realtime AI Backend

A real-time WebSocket-based backend service that facilitates AI-driven conversations using the Gemini API and stores session history in Supabase.

## Setup Steps

### Prerequisites
- Python 3.9+
- A Supabase project
- A Google Cloud project with Gemini API access

### Installation

1. **Clone the repository** (if applicable) and navigate to the project directory.

2. **Create a virtual environment**:
   ```bash
   python -m venv venv
   # Windows
   .\venv\Scripts\activate
   # Mac/Linux
   source venv/bin/activate
   ```

3. **Install dependencies**:
   ```bash
   pip install -r requirements.txt
   ```

4. **Environment Configuration**:
   Create a `.env` file in the root directory with the following variables:
   ```env
   SUPABASE_URL=your_supabase_url
   SUPABASE_KEY=your_supabase_anon_key
   GEMINI_API_KEY=your_google_gemini_api_key
   ```

### Database Setup

Run the following SQL commands in your Supabase SQL Editor to set up the necessary tables:

```sql
-- Create a table for sessions
create table public.sessions (
  session_id uuid not null primary key,
  user_id text, -- Can be optional if anonymous
  start_time timestamp with time zone default timezone('utc'::text, now()) not null,
  end_time timestamp with time zone,
  summary text,
  duration_seconds integer
);

-- Create a table for events (logs)
create table public.events (
  event_id bigint generated by default as identity primary key,
  session_id uuid references public.sessions(session_id) on delete cascade not null,
  timestamp timestamp with time zone default timezone('utc'::text, now()) not null,
  event_type text not null, -- 'user_message', 'ai_message', 'tool_call', 'tool_result'
  content text
);

-- Enable Row Level Security (RLS)
alter table public.sessions enable row level security;
alter table public.events enable row level security;

-- Create policies (Adjust as needed for production)
create policy "Allow public insert" on public.sessions for insert with check (true);
create policy "Allow public select" on public.sessions for select using (true);
create policy "Allow public update" on public.sessions for update using (true);

create policy "Allow public insert" on public.events for insert with check (true);
create policy "Allow public select" on public.events for select using (true);
```

## Running the Server

Start the development server using **Uvicorn**:

```bash
uvicorn app.main:app --reload
```

The server will start at `http://127.0.0.1:8000`.

## Testing the WebSocket

You can connect to the WebSocket endpoint to test the conversation flow.

**Endpoint**: `ws://127.0.0.1:8000/ws/session/{session_id}`

Replace `{session_id}` with a valid UUID.

**Example using a client like Postman or a custom script:**
1. Connect to `ws://127.0.0.1:8000/ws/session/550e8400-e29b-41d4-a716-446655440000`
2. Send a text message (e.g., "How's the weather in Delhi ?").
3. Receive the streamed response from the AI.

## Key Design Choices

### 1. **FastAPI for Async WebSockets**
We chose **FastAPI** because of its native support for asynchronous programming and WebSockets. This allows for handling multiple concurrent real-time connections efficiently without blocking the main thread, which is crucial for a chat application.

### 2. **Session Management**
State is managed in memory for active connections to ensure low latency.
- `SessionManager`: Handles WebSocket acceptance, message routing, and Gemini chat session persistence.
- **Supabase**: Acts as the persistent storage layer. Every message is asynchronously logged to the `events` table to maintain a permanent record of the conversation.

### 3. **AI Integration (Gemini)**
We utilize **Google's Gemini API** with streaming enabled (`stream=True`).
- This provides a responsive user experience by sending chunks of text as they are generated, rather than waiting for the entire response.
- **Tools**: The architecture supports function calling (e.g., `get_weather`), allowing the AI to interact with external data sources dynamically.

### 4. **Background Processing**
Session summarization is offloaded to **BackgroundTasks**.
- When a user disconnects, the system triggers a background job to fetch the entire conversation history and generate a concise summary.
- This ensures that the WebSocket disconnection is handled immediately on the client side, while heavy processing happens asynchronously.

### 5. **Database Schema**
A relational schema was chosen to clearly separate `Sessions` (metadata) from `Events` (actual chat logs).
- Foreign keys ensure data integrity.
- Timestamps support time-based analysis.
